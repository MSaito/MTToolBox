<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>MTToolBox: MTToolBox 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTToolBox
   &#160;<span id="projectnumber">0.2.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li class="current"><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>データ構造</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>名前空間一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>名前空間メンバ</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">データ構造</a> &#124;
<a href="#func-members">関数</a> &#124;
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">MTToolBox 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespace_m_t_tool_box.html" title="MTToolBox の名前空間 ">MTToolBox</a> の名前空間  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
データ構造</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_abstract_generator.html">AbstractGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">疑似乱数生成器  <a href="class_m_t_tool_box_1_1_abstract_generator.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_best_bits.html">AlgorithmBestBits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">テンパリングパラメータを探索するアルゴリズム(MT用)  <a href="class_m_t_tool_box_1_1_algorithm_best_bits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_calculate_parity.html">AlgorithmCalculateParity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">可約ジェネレータのパリティチェックベクトルを求める。  <a href="class_m_t_tool_box_1_1_algorithm_calculate_parity.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_equidistribution.html">AlgorithmEquidistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">疑似乱数生成器の均等分布次元を計算する  <a href="class_m_t_tool_box_1_1_algorithm_equidistribution.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_partial_bit_pattern.html">AlgorithmPartialBitPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">疑似乱数生成器の高次元均等分布性を改善するために、テンパ リングパラメータを探索するアルゴリズム  <a href="class_m_t_tool_box_1_1_algorithm_partial_bit_pattern.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_primitivity.html">AlgorithmPrimitivity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">原始多項式かどうか判定するアルゴリズムを提供するクラス  <a href="class_m_t_tool_box_1_1_algorithm_primitivity.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_recursion_and_tempering.html">AlgorithmRecursionAndTempering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_recursion_search.html">AlgorithmRecursionSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">状態遷移関数のパラメータを探索する。  <a href="class_m_t_tool_box_1_1_algorithm_recursion_search.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_equidistribution.html">AlgorithmReducibleEquidistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">可約ジェネレータの最悪の場合の均等分布次元を計算する。  <a href="class_m_t_tool_box_1_1_algorithm_reducible_equidistribution.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_recursion_and_tempering.html">AlgorithmReducibleRecursionAndTempering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_recursion_search.html">AlgorithmReducibleRecursionSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">可約ジェネレータの状態遷移関数のパラメータを探索する。  <a href="class_m_t_tool_box_1_1_algorithm_reducible_recursion_search.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_algorithm_tempering.html">AlgorithmTempering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">疑似乱数生成器の高次元均等分布性を改善するために、テンパ リングパラメータを探索するアルゴリズム  <a href="class_m_t_tool_box_1_1_algorithm_tempering.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_equidistribution_calculatable.html">EquidistributionCalculatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">このクラスはGF(2)線形疑似乱数生成器の均等分布次元を計算するためのクラスである。  <a href="class_m_t_tool_box_1_1_equidistribution_calculatable.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1linear__generator__vector.html">linear_generator_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GF(2)ベクトルとしてのGF(2)疑似乱数生成器  <a href="class_m_t_tool_box_1_1linear__generator__vector.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_mersenne_twister.html">MersenneTwister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mersenne Twister 疑似乱数生成器  <a href="class_m_t_tool_box_1_1_mersenne_twister.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_mersenne_twister64.html">MersenneTwister64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64 bit Mersenne Twister 疑似乱数生成器  <a href="class_m_t_tool_box_1_1_mersenne_twister64.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_recursion_searchable.html">RecursionSearchable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_reducible_generator.html">ReducibleGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">このクラスは特性多項式が可約なGF(2)線形疑似乱数生成器を開 発するためのクラスである。  <a href="class_m_t_tool_box_1_1_reducible_generator.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_reducible_tempering_calculatable.html">ReducibleTemperingCalculatable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_sequential.html">Sequential</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カウントダウン生成器  <a href="class_m_t_tool_box_1_1_sequential.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1temper__params.html">temper_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">テンパリングパラメータのクラス  <a href="class_m_t_tool_box_1_1temper__params.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_tempering_calculatable.html">TemperingCalculatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">テンパリングを行う可約ジェネレータは、このクラスを継承す ることによって、TemperingAlgorithmを使用したテンパリングパラメー タ探索が可能になる。  <a href="class_m_t_tool_box_1_1_tempering_calculatable.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t_tool_box_1_1_test_linearity.html">TestLinearity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">疑似乱数生成器がGF(2)線形であるかどうかテストする  <a href="class_m_t_tool_box_1_1_test_linearity.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:a402cebc7daf73e0c7662f33933e78056"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V  = U&gt; </td></tr>
<tr class="memitem:a402cebc7daf73e0c7662f33933e78056"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a402cebc7daf73e0c7662f33933e78056">calcCharacteristicPolynomial</a> (<a class="el" href="class_m_t_tool_box_1_1_recursion_searchable.html">RecursionSearchable</a>&lt; U, V &gt; *rand, NTL::GF2X &amp;poly)</td></tr>
<tr class="separator:a402cebc7daf73e0c7662f33933e78056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb80c19da61ef7051b0b9f907fcb11b5"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V  = U&gt; </td></tr>
<tr class="memitem:afb80c19da61ef7051b0b9f907fcb11b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#afb80c19da61ef7051b0b9f907fcb11b5">calcCharacteristicPolynomial</a> (<a class="el" href="class_m_t_tool_box_1_1_reducible_generator.html">ReducibleGenerator</a>&lt; U, V &gt; *rand, NTL::GF2X &amp;poly)</td></tr>
<tr class="memdesc:afb80c19da61ef7051b0b9f907fcb11b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reducible Generator の特性多項式の計算 実のところ、特性多項式ではなく最小多項式のLCMを計算しているに過ぎない。 次数が一致すれば特性多項式。特性多項式でなくても、MTToolBoxで使用する 範囲内では特に問題はない。  <a href="#afb80c19da61ef7051b0b9f907fcb11b5">[詳解]</a><br /></td></tr>
<tr class="separator:afb80c19da61ef7051b0b9f907fcb11b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d01ea904e59bb7458e125ff8cd948"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a163d01ea904e59bb7458e125ff8cd948"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a163d01ea904e59bb7458e125ff8cd948">minpoly</a> (NTL::GF2X &amp;poly, <a class="el" href="class_m_t_tool_box_1_1_abstract_generator.html">AbstractGenerator</a>&lt; U &gt; &amp;generator, int pos=0, int stateSize=0)</td></tr>
<tr class="memdesc:a163d01ea904e59bb7458e125ff8cd948"><td class="mdescLeft">&#160;</td><td class="mdescRight">最小多項式を求める  <a href="#a163d01ea904e59bb7458e125ff8cd948">[詳解]</a><br /></td></tr>
<tr class="separator:a163d01ea904e59bb7458e125ff8cd948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321a25e0bd1bf2447a2dfffd9f960fa5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a321a25e0bd1bf2447a2dfffd9f960fa5">isMexp</a> (uint32_t degree)</td></tr>
<tr class="memdesc:a321a25e0bd1bf2447a2dfffd9f960fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>degree</sup> -1 が素数となるかどうかを返す  <a href="#a321a25e0bd1bf2447a2dfffd9f960fa5">[詳解]</a><br /></td></tr>
<tr class="separator:a321a25e0bd1bf2447a2dfffd9f960fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910150b2b4a1db3af4e77c498c1835dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a910150b2b4a1db3af4e77c498c1835dc">isIrreducible</a> (const NTL::GF2X &amp;poly)</td></tr>
<tr class="memdesc:a910150b2b4a1db3af4e77c498c1835dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">既約判定  <a href="#a910150b2b4a1db3af4e77c498c1835dc">[詳解]</a><br /></td></tr>
<tr class="separator:a910150b2b4a1db3af4e77c498c1835dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f94dcf95c07af9dca861231891dbb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a07f94dcf95c07af9dca861231891dbb0">isPrime</a> (const NTL::GF2X &amp;poly)</td></tr>
<tr class="memdesc:a07f94dcf95c07af9dca861231891dbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">原始性判定  <a href="#a07f94dcf95c07af9dca861231891dbb0">[詳解]</a><br /></td></tr>
<tr class="separator:a07f94dcf95c07af9dca861231891dbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e20f43e12f69f3a5d255fbad34e809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a77e20f43e12f69f3a5d255fbad34e809">isPrime</a> (const NTL::GF2X &amp;poly, int degree, const NTL::Vec&lt; NTL::ZZ &gt; &amp;prime_factors)</td></tr>
<tr class="memdesc:a77e20f43e12f69f3a5d255fbad34e809"><td class="mdescLeft">&#160;</td><td class="mdescRight">原始性判定  <a href="#a77e20f43e12f69f3a5d255fbad34e809">[詳解]</a><br /></td></tr>
<tr class="separator:a77e20f43e12f69f3a5d255fbad34e809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2d18bc039c136eae772077692bb5a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a2c2d18bc039c136eae772077692bb5a3">isPrime</a> (const NTL::GF2X &amp;poly, int degree, const char *prime_factors[])</td></tr>
<tr class="memdesc:a2c2d18bc039c136eae772077692bb5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">原始性判定  <a href="#a2c2d18bc039c136eae772077692bb5a3">[詳解]</a><br /></td></tr>
<tr class="separator:a2c2d18bc039c136eae772077692bb5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bcb3353334840e792ed780d1157e5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a14bcb3353334840e792ed780d1157e5c">hasFactorOfDegree</a> (NTL::GF2X &amp;poly, long degree)</td></tr>
<tr class="memdesc:a14bcb3353334840e792ed780d1157e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された次数の原始多項式がpolyの因数分解に含まれているか判定する。  <a href="#a14bcb3353334840e792ed780d1157e5c">[詳解]</a><br /></td></tr>
<tr class="separator:a14bcb3353334840e792ed780d1157e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1598ecd7124d7facdc461f0ecf343cc"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V  = U&gt; </td></tr>
<tr class="memitem:ab1598ecd7124d7facdc461f0ecf343cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#ab1598ecd7124d7facdc461f0ecf343cc">annihilate</a> (<a class="el" href="class_m_t_tool_box_1_1_equidistribution_calculatable.html">EquidistributionCalculatable</a>&lt; U, V &gt; *rg, const NTL::GF2X &amp;poly)</td></tr>
<tr class="memdesc:ab1598ecd7124d7facdc461f0ecf343cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">可約疑似乱数生成器の状態空間を多項式で殲滅する。  <a href="#ab1598ecd7124d7facdc461f0ecf343cc">[詳解]</a><br /></td></tr>
<tr class="separator:ab1598ecd7124d7facdc461f0ecf343cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0cc4161a8a989b21de16672c7bacbb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a8d0cc4161a8a989b21de16672c7bacbb">count_bit</a> (uint16_t x)</td></tr>
<tr class="memdesc:a8d0cc4161a8a989b21de16672c7bacbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 の個数を数える  <a href="#a8d0cc4161a8a989b21de16672c7bacbb">[詳解]</a><br /></td></tr>
<tr class="separator:a8d0cc4161a8a989b21de16672c7bacbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab57e10f8be2324f4124536a8bdc39"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a62ab57e10f8be2324f4124536a8bdc39">count_bit</a> (uint32_t x)</td></tr>
<tr class="memdesc:a62ab57e10f8be2324f4124536a8bdc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 の個数を数える  <a href="#a62ab57e10f8be2324f4124536a8bdc39">[詳解]</a><br /></td></tr>
<tr class="separator:a62ab57e10f8be2324f4124536a8bdc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f0b50d675ee3ac8de6cd3f0b9b1eb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#ada7f0b50d675ee3ac8de6cd3f0b9b1eb">count_bit</a> (uint64_t x)</td></tr>
<tr class="memdesc:ada7f0b50d675ee3ac8de6cd3f0b9b1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 の個数を数える  <a href="#ada7f0b50d675ee3ac8de6cd3f0b9b1eb">[詳解]</a><br /></td></tr>
<tr class="separator:ada7f0b50d675ee3ac8de6cd3f0b9b1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0e1393f674c0eac3b7269f852486ac"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a1f0e1393f674c0eac3b7269f852486ac">reverse_bit</a> (uint32_t x)</td></tr>
<tr class="memdesc:a1f0e1393f674c0eac3b7269f852486ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビットを反転する  <a href="#a1f0e1393f674c0eac3b7269f852486ac">[詳解]</a><br /></td></tr>
<tr class="separator:a1f0e1393f674c0eac3b7269f852486ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e563eb2151bb605b60da397c5fad7f"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a26e563eb2151bb605b60da397c5fad7f">reverse_bit</a> (uint64_t x)</td></tr>
<tr class="memdesc:a26e563eb2151bb605b60da397c5fad7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビットを反転する  <a href="#a26e563eb2151bb605b60da397c5fad7f">[詳解]</a><br /></td></tr>
<tr class="separator:a26e563eb2151bb605b60da397c5fad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7fe113e116d591fd4c006ae4a3ec05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e7fe113e116d591fd4c006ae4a3ec05"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a7e7fe113e116d591fd4c006ae4a3ec05">bit_size</a> ()</td></tr>
<tr class="memdesc:a7e7fe113e116d591fd4c006ae4a3ec05"><td class="mdescLeft">&#160;</td><td class="mdescRight">T のビットサイズを返す。  <a href="#a7e7fe113e116d591fd4c006ae4a3ec05">[詳解]</a><br /></td></tr>
<tr class="separator:a7e7fe113e116d591fd4c006ae4a3ec05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbf5b1b0ad367bccd4c19ff281fb88f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a8fbf5b1b0ad367bccd4c19ff281fb88f">UNUSED_VARIABLE</a> (void *x)</td></tr>
<tr class="memdesc:a8fbf5b1b0ad367bccd4c19ff281fb88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用しない変数のワーニングを止める  <a href="#a8fbf5b1b0ad367bccd4c19ff281fb88f">[詳解]</a><br /></td></tr>
<tr class="separator:a8fbf5b1b0ad367bccd4c19ff281fb88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe01232a623b92053b22dc08bb70a54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affe01232a623b92053b22dc08bb70a54"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#affe01232a623b92053b22dc08bb70a54">floor2p</a> (T n)</td></tr>
<tr class="memdesc:affe01232a623b92053b22dc08bb70a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">n を越えない最大の2のべき乗を返す。  <a href="#affe01232a623b92053b22dc08bb70a54">[詳解]</a><br /></td></tr>
<tr class="separator:affe01232a623b92053b22dc08bb70a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efab9c60840a6b341ef525a0ad04210"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a8efab9c60840a6b341ef525a0ad04210">print_binary</a> (std::ostream &amp;os, NTL::GF2X &amp;poly, bool breakline=true)</td></tr>
<tr class="memdesc:a8efab9c60840a6b341ef525a0ad04210"><td class="mdescLeft">&#160;</td><td class="mdescRight">出力ストリーム <b>os</b> に多項式 <b>poly</b> を01の文字列で出力する。  <a href="#a8efab9c60840a6b341ef525a0ad04210">[詳解]</a><br /></td></tr>
<tr class="separator:a8efab9c60840a6b341ef525a0ad04210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30abfd018fb12ac7ae7d18325979efee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30abfd018fb12ac7ae7d18325979efee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a30abfd018fb12ac7ae7d18325979efee">get_range</a> (T input, int start, int end)</td></tr>
<tr class="memdesc:a30abfd018fb12ac7ae7d18325979efee"><td class="mdescLeft">&#160;</td><td class="mdescRight">input を start と end の間の数に変換する。  <a href="#a30abfd018fb12ac7ae7d18325979efee">[詳解]</a><br /></td></tr>
<tr class="separator:a30abfd018fb12ac7ae7d18325979efee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b91c6dd6e6479a30f9a4954ba44995"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24b91c6dd6e6479a30f9a4954ba44995"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a24b91c6dd6e6479a30f9a4954ba44995">fill_table</a> (T dist_tbl[], T src_tbl[], int size)</td></tr>
<tr class="memdesc:a24b91c6dd6e6479a30f9a4954ba44995"><td class="mdescLeft">&#160;</td><td class="mdescRight">GF(2)ベクトルのパラメータテーブルから、より高速で冗長なルックアップテーブルを作成する。  <a href="#a24b91c6dd6e6479a30f9a4954ba44995">[詳解]</a><br /></td></tr>
<tr class="separator:a24b91c6dd6e6479a30f9a4954ba44995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac1d869b7d96c78f770cc89260aee0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a96ac1d869b7d96c78f770cc89260aee0">calc_1pos</a> (uint16_t x)</td></tr>
<tr class="memdesc:a96ac1d869b7d96c78f770cc89260aee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力をビット列とみなして最上位の1の位置を0とした最も右側の（下位の）1の位置を返す。  <a href="#a96ac1d869b7d96c78f770cc89260aee0">[詳解]</a><br /></td></tr>
<tr class="separator:a96ac1d869b7d96c78f770cc89260aee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edb26e368ab8516b30626b9638fb271"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a9edb26e368ab8516b30626b9638fb271">calc_1pos</a> (uint32_t x)</td></tr>
<tr class="memdesc:a9edb26e368ab8516b30626b9638fb271"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力をビット列とみなして最上位の1の位置を0とした最も右側の（下位の）1の位置を返す。  <a href="#a9edb26e368ab8516b30626b9638fb271">[詳解]</a><br /></td></tr>
<tr class="separator:a9edb26e368ab8516b30626b9638fb271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e7906a857b3e29a910537e5d606a38"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a03e7906a857b3e29a910537e5d606a38">calc_1pos</a> (uint64_t x)</td></tr>
<tr class="memdesc:a03e7906a857b3e29a910537e5d606a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力をビット列とみなして最上位の1の位置を0とした最も右側の（下位の）1の位置を返す。  <a href="#a03e7906a857b3e29a910537e5d606a38">[詳解]</a><br /></td></tr>
<tr class="separator:a03e7906a857b3e29a910537e5d606a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddba044611fd649ec7af6ba41737759"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#aaddba044611fd649ec7af6ba41737759">LCM</a> (NTL::GF2X &amp;lcm, const NTL::GF2X &amp;x, const NTL::GF2X &amp;y)</td></tr>
<tr class="memdesc:aaddba044611fd649ec7af6ba41737759"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式の最小公倍数を求める。  <a href="#aaddba044611fd649ec7af6ba41737759">[詳解]</a><br /></td></tr>
<tr class="separator:aaddba044611fd649ec7af6ba41737759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8f6f376710a5d09992e8332c762aa6"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aaf8f6f376710a5d09992e8332c762aa6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#aaf8f6f376710a5d09992e8332c762aa6">toGF2Vec</a> (NTL::vec_GF2 &amp;result, U value)</td></tr>
<tr class="memdesc:aaf8f6f376710a5d09992e8332c762aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">符号なし整数をGF(2)ベクトルに変換する。 上位ビットがベクトルの初めの要素になる。（デバッグの時見やすいように）  <a href="#aaf8f6f376710a5d09992e8332c762aa6">[詳解]</a><br /></td></tr>
<tr class="separator:aaf8f6f376710a5d09992e8332c762aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc163ed96b5d844bec46b63320426aed"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acc163ed96b5d844bec46b63320426aed"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#acc163ed96b5d844bec46b63320426aed">getOne</a> ()</td></tr>
<tr class="memdesc:acc163ed96b5d844bec46b63320426aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">その型の1を返す SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。  <a href="#acc163ed96b5d844bec46b63320426aed">[詳解]</a><br /></td></tr>
<tr class="separator:acc163ed96b5d844bec46b63320426aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9e90a7e18e5cea7faf5e88b33a0e9e"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0a9e90a7e18e5cea7faf5e88b33a0e9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a0a9e90a7e18e5cea7faf5e88b33a0e9e">setZero</a> (U &amp;x)</td></tr>
<tr class="memdesc:a0a9e90a7e18e5cea7faf5e88b33a0e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ゼロをセットする SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。  <a href="#a0a9e90a7e18e5cea7faf5e88b33a0e9e">[詳解]</a><br /></td></tr>
<tr class="separator:a0a9e90a7e18e5cea7faf5e88b33a0e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6012795eccfa54f44eae575d35f6d160"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6012795eccfa54f44eae575d35f6d160"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a6012795eccfa54f44eae575d35f6d160">getBitOfPos</a> (U bits, int pos)</td></tr>
<tr class="memdesc:a6012795eccfa54f44eae575d35f6d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">特定位置のビットを求める SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。  <a href="#a6012795eccfa54f44eae575d35f6d160">[詳解]</a><br /></td></tr>
<tr class="separator:a6012795eccfa54f44eae575d35f6d160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2fcf94fbfc715cdf8fa286ee69cb10"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aff2fcf94fbfc715cdf8fa286ee69cb10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#aff2fcf94fbfc715cdf8fa286ee69cb10">setBitOfPos</a> (U *bits, int pos, unsigned int b)</td></tr>
<tr class="memdesc:aff2fcf94fbfc715cdf8fa286ee69cb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数の指定位置のビットを1または0にセットする SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。  <a href="#aff2fcf94fbfc715cdf8fa286ee69cb10">[詳解]</a><br /></td></tr>
<tr class="separator:aff2fcf94fbfc715cdf8fa286ee69cb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928f4d3aa9e5458a6f0404f22dbf343c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a928f4d3aa9e5458a6f0404f22dbf343c"><td class="memTemplItemLeft" align="right" valign="top">static U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a928f4d3aa9e5458a6f0404f22dbf343c">fromGF2Vec</a> (NTL::vec_GF2 &amp;value)</td></tr>
<tr class="memdesc:a928f4d3aa9e5458a6f0404f22dbf343c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GF(2)ベクトルを符号なし整数に変換する。 上位ビットがベクトルの初めの要素になる。（デバッグの時見やすいように）  <a href="#a928f4d3aa9e5458a6f0404f22dbf343c">[詳解]</a><br /></td></tr>
<tr class="separator:a928f4d3aa9e5458a6f0404f22dbf343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3ac1c9e4450b22633fce7c5925f9e0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9a3ac1c9e4450b22633fce7c5925f9e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a9a3ac1c9e4450b22633fce7c5925f9e0">isZero</a> (U x)</td></tr>
<tr class="memdesc:a9a3ac1c9e4450b22633fce7c5925f9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ゼロかどうか、判定する。 SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。  <a href="#a9a3ac1c9e4450b22633fce7c5925f9e0">[詳解]</a><br /></td></tr>
<tr class="separator:a9a3ac1c9e4450b22633fce7c5925f9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71bc993aaacdb16a3d7a562b6eb1236"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V &gt; </td></tr>
<tr class="memitem:ad71bc993aaacdb16a3d7a562b6eb1236"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#ad71bc993aaacdb16a3d7a562b6eb1236">convert</a> (V x)</td></tr>
<tr class="memdesc:ad71bc993aaacdb16a3d7a562b6eb1236"><td class="mdescLeft">&#160;</td><td class="mdescRight">V 型をU型に変換する SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。  <a href="#ad71bc993aaacdb16a3d7a562b6eb1236">[詳解]</a><br /></td></tr>
<tr class="separator:ad71bc993aaacdb16a3d7a562b6eb1236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf8a95c6e03c4ee8f5281488b5427c1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#acbf8a95c6e03c4ee8f5281488b5427c1">get_mttoolbox_version</a> ()</td></tr>
<tr class="memdesc:acbf8a95c6e03c4ee8f5281488b5427c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns library version  <a href="#acbf8a95c6e03c4ee8f5281488b5427c1">[詳解]</a><br /></td></tr>
<tr class="separator:acbf8a95c6e03c4ee8f5281488b5427c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
変数</h2></td></tr>
<tr class="memitem:a34e4fb3d4edbdec76092186b4f2259ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_t_tool_box_1_1_algorithm_primitivity.html">AlgorithmPrimitivity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a34e4fb3d4edbdec76092186b4f2259ba">MersennePrimitivity</a></td></tr>
<tr class="memdesc:a34e4fb3d4edbdec76092186b4f2259ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">状態空間のビットサイズがメルセンヌ指数の疑似乱数生成器の 最小多項式の原始性を判定するアルゴリズム  <a href="#a34e4fb3d4edbdec76092186b4f2259ba">[詳解]</a><br /></td></tr>
<tr class="separator:a34e4fb3d4edbdec76092186b4f2259ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe4107d6c4f4dbb809fd66ec2dbee45"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a2fe4107d6c4f4dbb809fd66ec2dbee45">prime_factors2_128_1</a> []</td></tr>
<tr class="memdesc:a2fe4107d6c4f4dbb809fd66ec2dbee45"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>128</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a2fe4107d6c4f4dbb809fd66ec2dbee45">[詳解]</a><br /></td></tr>
<tr class="separator:a2fe4107d6c4f4dbb809fd66ec2dbee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99207a7c9ddd352220636cd36b1a8799"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a99207a7c9ddd352220636cd36b1a8799">prime_factors2_160_1</a> []</td></tr>
<tr class="memdesc:a99207a7c9ddd352220636cd36b1a8799"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>160</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a99207a7c9ddd352220636cd36b1a8799">[詳解]</a><br /></td></tr>
<tr class="separator:a99207a7c9ddd352220636cd36b1a8799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5379d649fd6a9f9e5547b8e373a9fbf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#aa5379d649fd6a9f9e5547b8e373a9fbf">prime_factors2_192_1</a> []</td></tr>
<tr class="memdesc:aa5379d649fd6a9f9e5547b8e373a9fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>192</sup>-1 の素因数分解に現れる素数のリスト  <a href="#aa5379d649fd6a9f9e5547b8e373a9fbf">[詳解]</a><br /></td></tr>
<tr class="separator:aa5379d649fd6a9f9e5547b8e373a9fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61499a45bffaa0ba8af6cfe0c21f9151"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a61499a45bffaa0ba8af6cfe0c21f9151">prime_factors2_224_1</a> []</td></tr>
<tr class="memdesc:a61499a45bffaa0ba8af6cfe0c21f9151"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>224</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a61499a45bffaa0ba8af6cfe0c21f9151">[詳解]</a><br /></td></tr>
<tr class="separator:a61499a45bffaa0ba8af6cfe0c21f9151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffddfdc0cdf7ebd6e37e0e43e4de02e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a3ffddfdc0cdf7ebd6e37e0e43e4de02e">prime_factors2_256_1</a> []</td></tr>
<tr class="memdesc:a3ffddfdc0cdf7ebd6e37e0e43e4de02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>256</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a3ffddfdc0cdf7ebd6e37e0e43e4de02e">[詳解]</a><br /></td></tr>
<tr class="separator:a3ffddfdc0cdf7ebd6e37e0e43e4de02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1445b9146c030fe12bf611fb3752df36"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a1445b9146c030fe12bf611fb3752df36">prime_factors2_288_1</a> []</td></tr>
<tr class="memdesc:a1445b9146c030fe12bf611fb3752df36"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>288</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a1445b9146c030fe12bf611fb3752df36">[詳解]</a><br /></td></tr>
<tr class="separator:a1445b9146c030fe12bf611fb3752df36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac57ea226f682e507c79ad1338d9dd9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a5ac57ea226f682e507c79ad1338d9dd9">prime_factors2_320_1</a> []</td></tr>
<tr class="memdesc:a5ac57ea226f682e507c79ad1338d9dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>320</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a5ac57ea226f682e507c79ad1338d9dd9">[詳解]</a><br /></td></tr>
<tr class="separator:a5ac57ea226f682e507c79ad1338d9dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dd8cd81d96b308b5088db059275762"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a52dd8cd81d96b308b5088db059275762">prime_factors2_352_1</a> []</td></tr>
<tr class="memdesc:a52dd8cd81d96b308b5088db059275762"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>352</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a52dd8cd81d96b308b5088db059275762">[詳解]</a><br /></td></tr>
<tr class="separator:a52dd8cd81d96b308b5088db059275762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd7146bb2466447d04f74ce5f7def80"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a6fd7146bb2466447d04f74ce5f7def80">prime_factors2_384_1</a> []</td></tr>
<tr class="memdesc:a6fd7146bb2466447d04f74ce5f7def80"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>384</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a6fd7146bb2466447d04f74ce5f7def80">[詳解]</a><br /></td></tr>
<tr class="separator:a6fd7146bb2466447d04f74ce5f7def80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c746ad021307f50c2005d6043ab5a05"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a5c746ad021307f50c2005d6043ab5a05">prime_factors2_416_1</a> []</td></tr>
<tr class="memdesc:a5c746ad021307f50c2005d6043ab5a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>416</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a5c746ad021307f50c2005d6043ab5a05">[詳解]</a><br /></td></tr>
<tr class="separator:a5c746ad021307f50c2005d6043ab5a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab416912e186693889f954d3491d6cb0c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#ab416912e186693889f954d3491d6cb0c">prime_factors2_448_1</a> []</td></tr>
<tr class="memdesc:ab416912e186693889f954d3491d6cb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>448</sup>-1 の素因数分解に現れる素数のリスト  <a href="#ab416912e186693889f954d3491d6cb0c">[詳解]</a><br /></td></tr>
<tr class="separator:ab416912e186693889f954d3491d6cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95557bee413c7de118239b94ca73585b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a95557bee413c7de118239b94ca73585b">prime_factors2_480_1</a> []</td></tr>
<tr class="memdesc:a95557bee413c7de118239b94ca73585b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>480</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a95557bee413c7de118239b94ca73585b">[詳解]</a><br /></td></tr>
<tr class="separator:a95557bee413c7de118239b94ca73585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f33f9f028e13832f14873b6deb7a32c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a6f33f9f028e13832f14873b6deb7a32c">prime_factors2_512_1</a> []</td></tr>
<tr class="memdesc:a6f33f9f028e13832f14873b6deb7a32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>512</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a6f33f9f028e13832f14873b6deb7a32c">[詳解]</a><br /></td></tr>
<tr class="separator:a6f33f9f028e13832f14873b6deb7a32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98557ab36e5ee51547221d9938db98cb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_t_tool_box.html#a98557ab36e5ee51547221d9938db98cb">prime_factors2_544_1</a> []</td></tr>
<tr class="memdesc:a98557ab36e5ee51547221d9938db98cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">2<sup>544</sup>-1 の素因数分解に現れる素数のリスト  <a href="#a98557ab36e5ee51547221d9938db98cb">[詳解]</a><br /></td></tr>
<tr class="separator:a98557ab36e5ee51547221d9938db98cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p><a class="el" href="namespace_m_t_tool_box.html" title="MTToolBox の名前空間 ">MTToolBox</a> の名前空間 </p>
</div><h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="ab1598ecd7124d7facdc461f0ecf343cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V  = U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MTToolBox::annihilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_t_tool_box_1_1_equidistribution_calculatable.html">EquidistributionCalculatable</a>&lt; U, V &gt; *&#160;</td>
          <td class="paramname"><em>rg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>可約疑似乱数生成器の状態空間を多項式で殲滅する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>疑似乱数生成器の出力の型 </td></tr>
    <tr><td class="paramname">V</td><td>疑似乱数生成器の内部パラメータを決める際に使う乱数生成器の出力の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rg</td><td>可約疑似乱数生成器 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>殲滅多項式 </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="class_m_t_tool_box_1_1_equidistribution_calculatable.html#afb4878dde253bab920664c6b78eb7908">MTToolBox::EquidistributionCalculatable&lt; U, V &gt;::add()</a>, <a class="el" href="class_m_t_tool_box_1_1_equidistribution_calculatable.html#afd223ce8c3fd6c2f1045da04b9dcf284">MTToolBox::EquidistributionCalculatable&lt; U, V &gt;::clone()</a>, <a class="el" href="class_m_t_tool_box_1_1_equidistribution_calculatable.html#a051865807220bd067b381425d763729f">MTToolBox::EquidistributionCalculatable&lt; U, V &gt;::generate()</a>, <a class="el" href="class_m_t_tool_box_1_1_equidistribution_calculatable.html#a5875bd1947c2172b6863173187310d20">MTToolBox::EquidistributionCalculatable&lt; U, V &gt;::setZero()</a>.</p>

<p>参照元 <a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_recursion_and_tempering.html#ae0b7c1e8b838238a73c58257caa3f9c0">MTToolBox::AlgorithmReducibleRecursionAndTempering&lt; U, G &gt;::search()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e7fe113e116d591fd4c006ae4a3ec05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int MTToolBox::bit_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>T のビットサイズを返す。 </p>
<p>sizeof に 8 を掛けているだけなので正確ではない。</p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>ビットサイズを知りたい型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>T のビットサイズ </dd></dl>

</div>
</div>
<a class="anchor" id="a96ac1d869b7d96c78f770cc89260aee0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MTToolBox::calc_1pos </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>入力をビット列とみなして最上位の1の位置を0とした最も右側の（下位の）1の位置を返す。 </p>
<p>1の位置を求めるアルゴリズムは以下のページのものを使用した。 </p><dl class="section see"><dt>参照</dt><dd><a href="http://aggregate.org/MAGIC/#Trailing">http://aggregate.org/MAGIC/#Trailing</a> Zero Count </dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>入力 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>最下位の1のあるビットの上位から数えた位置を返す。 </dd></dl>

<p>参照先 <a class="el" href="namespace_m_t_tool_box.html#a8d0cc4161a8a989b21de16672c7bacbb">count_bit()</a>.</p>

</div>
</div>
<a class="anchor" id="a9edb26e368ab8516b30626b9638fb271"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MTToolBox::calc_1pos </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>入力をビット列とみなして最上位の1の位置を0とした最も右側の（下位の）1の位置を返す。 </p>
<p>1の位置を求めるアルゴリズムは以下のページのものを使用した。 </p><dl class="section see"><dt>参照</dt><dd><a href="http://aggregate.org/MAGIC/#Trailing">http://aggregate.org/MAGIC/#Trailing</a> Zero Count </dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>入力 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>最下位の1のあるビットの上位から数えた位置を返す。 例<ul>
<li>
calc_1pos(0x80000000U) は 0を返す。 </li>
<li>
calc_1pos(0x80000002U) は30を返す。 </li>
<li>
calc_1pos(0) は -1 を返す。 </li>
</ul>
</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>入力 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>最下位の1のあるビットの上位から数えた位置を返す。 </dd></dl>

<p>参照先 <a class="el" href="namespace_m_t_tool_box.html#a8d0cc4161a8a989b21de16672c7bacbb">count_bit()</a>.</p>

</div>
</div>
<a class="anchor" id="a03e7906a857b3e29a910537e5d606a38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MTToolBox::calc_1pos </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>入力をビット列とみなして最上位の1の位置を0とした最も右側の（下位の）1の位置を返す。 </p>
<p>1の位置を求めるアルゴリズムは以下のページのものを使用した。 </p><dl class="section see"><dt>参照</dt><dd><a href="http://aggregate.org/MAGIC/#Trailing">http://aggregate.org/MAGIC/#Trailing</a> Zero Count </dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>入力 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>最下位の1のあるビットの上位から数えた位置を返す。 例<ul>
<li>
calc_1pos(UINT64_C(0x8000000000000000)) は 0を返す。 </li>
<li>
calc_1pos(UINT64_C(0x8000000000000002)) は62を返す。 </li>
<li>
calc_1pos(0) は -1 を返す。 </li>
</ul>
</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>入力 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>最下位の1のあるビットの上位から数えた位置を返す。 </dd></dl>

<p>参照先 <a class="el" href="namespace_m_t_tool_box.html#a8d0cc4161a8a989b21de16672c7bacbb">count_bit()</a>.</p>

</div>
</div>
<a class="anchor" id="a402cebc7daf73e0c7662f33933e78056"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V  = U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MTToolBox::calcCharacteristicPolynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_t_tool_box_1_1_recursion_searchable.html">RecursionSearchable</a>&lt; U, V &gt; *&#160;</td>
          <td class="paramname"><em>rand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>参照元 <a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_equidistribution.html#a2b201dce9be4f4fcf6f36c9952d23c37">MTToolBox::AlgorithmReducibleEquidistribution&lt; U, G, V &gt;::AlgorithmReducibleEquidistribution()</a>, <a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_recursion_and_tempering.html#ae0b7c1e8b838238a73c58257caa3f9c0">MTToolBox::AlgorithmReducibleRecursionAndTempering&lt; U, G &gt;::search()</a>.</p>

</div>
</div>
<a class="anchor" id="afb80c19da61ef7051b0b9f907fcb11b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V  = U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MTToolBox::calcCharacteristicPolynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_t_tool_box_1_1_reducible_generator.html">ReducibleGenerator</a>&lt; U, V &gt; *&#160;</td>
          <td class="paramname"><em>rand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reducible Generator の特性多項式の計算 実のところ、特性多項式ではなく最小多項式のLCMを計算しているに過ぎない。 次数が一致すれば特性多項式。特性多項式でなくても、MTToolBoxで使用する 範囲内では特に問題はない。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>疑似乱数生成器の返す値の型 </td></tr>
    <tr><td class="paramname">V</td><td>パラメータ生成器の返す値の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rand</td><td>疑似乱数生成器 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">poly</td><td>特性多項式 </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="class_m_t_tool_box_1_1_abstract_generator.html#a9d1d8f6dc01860875cd0849325158b5a">MTToolBox::AbstractGenerator&lt; U &gt;::bitSize()</a>, <a class="el" href="namespace_m_t_tool_box.html#aaddba044611fd649ec7af6ba41737759">LCM()</a>, <a class="el" href="namespace_m_t_tool_box.html#a163d01ea904e59bb7458e125ff8cd948">minpoly()</a>.</p>

</div>
</div>
<a class="anchor" id="ad71bc993aaacdb16a3d7a562b6eb1236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U MTToolBox::convert </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>V 型をU型に変換する SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>変換先の型 </td></tr>
    <tr><td class="paramname">V</td><td>変換元変数の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>変数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>U 型の値 </dd></dl>

</div>
</div>
<a class="anchor" id="a8d0cc4161a8a989b21de16672c7bacbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MTToolBox::count_bit </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1 の個数を数える </p>
<p>レジスタ内SIMDアルゴリズム <a href="http://aggregate.org/MAGIC/">http://aggregate.org/MAGIC/</a> より引用</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x の中の1の個数 </dd></dl>

<p>参照元 <a class="el" href="namespace_m_t_tool_box.html#a96ac1d869b7d96c78f770cc89260aee0">calc_1pos()</a>.</p>

</div>
</div>
<a class="anchor" id="a62ab57e10f8be2324f4124536a8bdc39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MTToolBox::count_bit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1 の個数を数える </p>
<p>レジスタ内SIMDアルゴリズム <a href="http://aggregate.org/MAGIC/">http://aggregate.org/MAGIC/</a> より引用</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x の中の1の個数 </dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x の中の1の個数 </dd></dl>

</div>
</div>
<a class="anchor" id="ada7f0b50d675ee3ac8de6cd3f0b9b1eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MTToolBox::count_bit </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1 の個数を数える </p>
<p>レジスタ内SIMDアルゴリズム <a href="http://aggregate.org/MAGIC/">http://aggregate.org/MAGIC/</a> より引用</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x の中の1の個数 </dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x の中の1の個数 </dd></dl>

</div>
</div>
<a class="anchor" id="a24b91c6dd6e6479a30f9a4954ba44995"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MTToolBox::fill_table </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dist_tbl</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src_tbl</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GF(2)ベクトルのパラメータテーブルから、より高速で冗長なルックアップテーブルを作成する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>テーブル内の符号なし整数の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dist_tbl</td><td>作成されるルックアップテーブル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_tbl</td><td>元になるGF(2)ベクトルのテーブル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td><b>dist_tbl　のサイズ</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affe01232a623b92053b22dc08bb70a54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T MTToolBox::floor2p </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>n を越えない最大の2のべき乗を返す。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>n の整数型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>整数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>n を越えない最大の2のべき乗 </dd></dl>

</div>
</div>
<a class="anchor" id="a928f4d3aa9e5458a6f0404f22dbf343c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static U MTToolBox::fromGF2Vec </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_GF2 &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GF(2)ベクトルを符号なし整数に変換する。 上位ビットがベクトルの初めの要素になる。（デバッグの時見やすいように） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>変換元GF(2)ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>変換後符合なし整数 </dd></dl>

<p>参照先 <a class="el" href="namespace_m_t_tool_box.html#aff2fcf94fbfc715cdf8fa286ee69cb10">setBitOfPos()</a>, <a class="el" href="namespace_m_t_tool_box.html#a0a9e90a7e18e5cea7faf5e88b33a0e9e">setZero()</a>.</p>

</div>
</div>
<a class="anchor" id="acbf8a95c6e03c4ee8f5281488b5427c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::get_mttoolbox_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns library version </p>
<dl class="section return"><dt>戻り値</dt><dd>library version string </dd></dl>

</div>
</div>
<a class="anchor" id="a30abfd018fb12ac7ae7d18325979efee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int MTToolBox::get_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>input を start と end の間の数に変換する。 </p>
<p>偏りは気にしない。 </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>入力 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>範囲の開始 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>範囲の終了 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><b>start</b> &lt;= <b>r</b> &lt;= <b>end</b> となるような r </dd></dl>

</div>
</div>
<a class="anchor" id="a6012795eccfa54f44eae575d35f6d160"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int MTToolBox::getBitOfPos </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>特定位置のビットを求める SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>ビットを求める型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bits</td><td>ビット列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>ビット位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>指定位置のビット、ゼロまたは１ </dd></dl>

<p>参照元 <a class="el" href="namespace_m_t_tool_box.html#a163d01ea904e59bb7458e125ff8cd948">minpoly()</a>.</p>

</div>
</div>
<a class="anchor" id="acc163ed96b5d844bec46b63320426aed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U MTToolBox::getOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>その型の1を返す SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>1を返す型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>指定された型の1 </dd></dl>

</div>
</div>
<a class="anchor" id="a14bcb3353334840e792ed780d1157e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MTToolBox::hasFactorOfDegree </td>
          <td>(</td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された次数の原始多項式がpolyの因数分解に含まれているか判定する。 </p>
<p>この関数は、SFMT, dSFMT の開発で使用される。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">poly</td><td>GF(2)係数多項式 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td><b>poly</b> に <b>degree</b> 次の原始多項式が含まれているか </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>true poly が指定する次数の原始多項式を含む場合 </dd></dl>

<p>参照元 <a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_recursion_search.html#ab40458e115185661671d93841797969b">MTToolBox::AlgorithmReducibleRecursionSearch&lt; U, V &gt;::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a910150b2b4a1db3af4e77c498c1835dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MTToolBox::isIrreducible </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>既約判定 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>GF(2)係数多項式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>true poly が既約の場合 </dd></dl>

</div>
</div>
<a class="anchor" id="a321a25e0bd1bf2447a2dfffd9f960fa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MTToolBox::isMexp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>degree</sup> -1 が素数となるかどうかを返す </p>
<p>メルセンヌ素数の指数のリストを元に判定しているので完全ではない。 疑似乱数生成器として使用する範囲であればカバーしている。 </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>判定するべき数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>true 2<sup>degree</sup> -1 が素数の場合 </dd></dl>

</div>
</div>
<a class="anchor" id="a07f94dcf95c07af9dca861231891dbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MTToolBox::isPrime </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>原始性判定 </p>
<p>この原始性判定は簡易版であり、poly の次数がメルセンヌ指数の場合のみ 正しい結果を返す。状態空間のビットサイズがメルセンヌ指数でない場合は、 この関数を使うべきではない。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>GF(2)係数多項式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>true poly の次数がメルセンヌ指数で、かつpolyが既約のとき </dd></dl>

<p>参照元 <a class="el" href="class_m_t_tool_box_1_1_algorithm_recursion_search.html#a9edd3137f351363392a33ee366262c8c">MTToolBox::AlgorithmRecursionSearch&lt; U, V &gt;::AlgorithmRecursionSearch()</a>, <a class="el" href="class_m_t_tool_box_1_1_algorithm_recursion_and_tempering.html#a7936299c98f98a7c601ce82de1d5f358">MTToolBox::AlgorithmRecursionAndTempering&lt; U, V &gt;::search()</a>, <a class="el" href="class_m_t_tool_box_1_1_algorithm_recursion_search.html#a370b28641319f7c3f95e61a89ee68aa2">MTToolBox::AlgorithmRecursionSearch&lt; U, V &gt;::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a77e20f43e12f69f3a5d255fbad34e809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MTToolBox::isPrime </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>prime_factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>原始性判定 </p>
<p>この関数は、poly の次数が degree でない場合は false を返す。 prime_factors には2<sup>degree</sup>-1 の素因数分解に現れる素数の リストを与える。2<sup>3</sup>のように通常は同じ素数を複数含むが、 多重度は考慮せずにひとつの素数を１回だけ含むリストを与えればよい。 prime_factors が正しくないと結果も正しくないであろう。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>GF(2)係数多項式 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>polyに期待する次数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prime_factors</td><td>2<sup>degree</sup>-1 の素因数分解に現れる素数のリスト </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>true poly が原始多項式の場合 </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2d18bc039c136eae772077692bb5a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MTToolBox::isPrime </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prime_factors</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>原始性判定 </p>
<p>この関数は、poly の次数が degree でない場合は false を返す。 prime_factors には2<sup>degree</sup>-1 の素因数分解に現れる素数の リストを与える。2<sup>3</sup>のように通常は同じ素数を複数含むが、 多重度は考慮せずにひとつの素数を１回だけ含むリストを与えればよい。 prime_factors が正しくないと結果も正しくないであろう。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>GF(2)係数多項式 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>polyに期待する次数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prime_factors</td><td>2<sup>degree</sup>-1 の素因数分解に現れる素数のリスト </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>true poly が原始多項式の場合 </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3ac1c9e4450b22633fce7c5925f9e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MTToolBox::isZero </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ゼロかどうか、判定する。 SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>変数の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>変数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>変数がゼロかどうか ゼロならtrue </dd></dl>

<p>参照元 <a class="el" href="class_m_t_tool_box_1_1linear__generator__vector.html#a1c63197cd22f90a8dfc48b31af214328">MTToolBox::linear_generator_vector&lt; U, V &gt;::next_state()</a>, <a class="el" href="class_m_t_tool_box_1_1_algorithm_calculate_parity.html#a3cf5a37fc7e4ad8d6bd8eda45bd25d4a">MTToolBox::AlgorithmCalculateParity&lt; U, G &gt;::searchParity()</a>.</p>

</div>
</div>
<a class="anchor" id="aaddba044611fd649ec7af6ba41737759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MTToolBox::LCM </td>
          <td>(</td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>lcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>多項式の最小公倍数を求める。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lcm</td><td>x と y の最小公倍数多項式 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>多項式 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>多項式 </td></tr>
  </table>
  </dd>
</dl>

<p>参照元 <a class="el" href="namespace_m_t_tool_box.html#afb80c19da61ef7051b0b9f907fcb11b5">calcCharacteristicPolynomial()</a>.</p>

</div>
</div>
<a class="anchor" id="a163d01ea904e59bb7458e125ff8cd948"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MTToolBox::minpoly </td>
          <td>(</td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_t_tool_box_1_1_abstract_generator.html">AbstractGenerator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stateSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最小多項式を求める </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>疑似乱数生成器の出力の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">poly</td><td>最小多項式 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generator</td><td>GF(2)疑似乱数生成器 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>出力の下位から何ビット目を見るかを指定する </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stateSize</td><td>状態空間のビットサイズ </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="class_m_t_tool_box_1_1_abstract_generator.html#a9d1d8f6dc01860875cd0849325158b5a">MTToolBox::AbstractGenerator&lt; U &gt;::bitSize()</a>, <a class="el" href="class_m_t_tool_box_1_1_abstract_generator.html#ac0654743a78f7eb84630936d16fd945e">MTToolBox::AbstractGenerator&lt; U &gt;::generate()</a>, <a class="el" href="namespace_m_t_tool_box.html#a6012795eccfa54f44eae575d35f6d160">getBitOfPos()</a>.</p>

<p>参照元 <a class="el" href="namespace_m_t_tool_box.html#afb80c19da61ef7051b0b9f907fcb11b5">calcCharacteristicPolynomial()</a>, <a class="el" href="class_m_t_tool_box_1_1_algorithm_reducible_recursion_search.html#ab40458e115185661671d93841797969b">MTToolBox::AlgorithmReducibleRecursionSearch&lt; U, V &gt;::start()</a>, <a class="el" href="class_m_t_tool_box_1_1_algorithm_recursion_search.html#a370b28641319f7c3f95e61a89ee68aa2">MTToolBox::AlgorithmRecursionSearch&lt; U, V &gt;::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a8efab9c60840a6b341ef525a0ad04210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MTToolBox::print_binary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>breakline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>出力ストリーム <b>os</b> に多項式 <b>poly</b> を01の文字列で出力する。 </p>
<p>次数の低い項の係数が先に出力される。（昇巾順）</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>出力ストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>出力される多項式 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">breakline</td><td>真なら32文字出力ごとに改行される。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f0e1393f674c0eac3b7269f852486ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t MTToolBox::reverse_bit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ビットを反転する </p>
<p>入力ビットの上位と下位を反転する。最上位ビットは最下位ビットになる レジスタ内SIMDアルゴリズム <a href="http://aggregate.org/MAGIC/">http://aggregate.org/MAGIC/</a> より引用 </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x を反転したビットパターン </dd></dl>

</div>
</div>
<a class="anchor" id="a26e563eb2151bb605b60da397c5fad7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t MTToolBox::reverse_bit </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ビットを反転する </p>
<p>入力ビットの上位と下位を反転する。最上位ビットは最下位ビットになる レジスタ内SIMDアルゴリズム <a href="http://aggregate.org/MAGIC/">http://aggregate.org/MAGIC/</a> より引用 </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x を反転したビットパターン </dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ビットパターン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x を反転したビットパターン </dd></dl>

</div>
</div>
<a class="anchor" id="aff2fcf94fbfc715cdf8fa286ee69cb10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MTToolBox::setBitOfPos </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>変数の指定位置のビットを1または0にセットする SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>変数の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bits</td><td>指定位置のビットをセットする変数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>指定位置 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>ビット, 0または1 </td></tr>
  </table>
  </dd>
</dl>

<p>参照元 <a class="el" href="namespace_m_t_tool_box.html#a928f4d3aa9e5458a6f0404f22dbf343c">fromGF2Vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a9e90a7e18e5cea7faf5e88b33a0e9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MTToolBox::setZero </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ゼロをセットする SIMD型は、そのSIMD型のファイルでこのテンプレートを特殊化する。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>0をセットする型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>ゼロをセットする変数 </td></tr>
  </table>
  </dd>
</dl>

<p>参照元 <a class="el" href="namespace_m_t_tool_box.html#a928f4d3aa9e5458a6f0404f22dbf343c">fromGF2Vec()</a>, <a class="el" href="class_m_t_tool_box_1_1linear__generator__vector.html#ae7eb3542041ff0fa509da63ccb80ed4d">MTToolBox::linear_generator_vector&lt; U, V &gt;::linear_generator_vector()</a>, <a class="el" href="class_m_t_tool_box_1_1_algorithm_calculate_parity.html#a3cf5a37fc7e4ad8d6bd8eda45bd25d4a">MTToolBox::AlgorithmCalculateParity&lt; U, G &gt;::searchParity()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf8f6f376710a5d09992e8332c762aa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MTToolBox::toGF2Vec </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_GF2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>符号なし整数をGF(2)ベクトルに変換する。 上位ビットがベクトルの初めの要素になる。（デバッグの時見やすいように） </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>変換元の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>結果のGF(2)ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>変換元符号なし整数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fbf5b1b0ad367bccd4c19ff281fb88f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MTToolBox::UNUSED_VARIABLE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>使用しない変数のワーニングを止める </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>使用しない変数へのポインタ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">変数詳解</h2>
<a class="anchor" id="a34e4fb3d4edbdec76092186b4f2259ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_t_tool_box_1_1_algorithm_primitivity.html">AlgorithmPrimitivity</a> MTToolBox::MersennePrimitivity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>状態空間のビットサイズがメルセンヌ指数の疑似乱数生成器の 最小多項式の原始性を判定するアルゴリズム </p>

<p>参照元 <a class="el" href="class_m_t_tool_box_1_1_algorithm_recursion_search.html#a9edd3137f351363392a33ee366262c8c">MTToolBox::AlgorithmRecursionSearch&lt; U, V &gt;::AlgorithmRecursionSearch()</a>.</p>

</div>
</div>
<a class="anchor" id="a2fe4107d6c4f4dbb809fd66ec2dbee45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_128_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>128</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a99207a7c9ddd352220636cd36b1a8799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_160_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>160</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="aa5379d649fd6a9f9e5547b8e373a9fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_192_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>192</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a61499a45bffaa0ba8af6cfe0c21f9151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_224_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>224</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a3ffddfdc0cdf7ebd6e37e0e43e4de02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_256_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>256</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a1445b9146c030fe12bf611fb3752df36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_288_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>288</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a5ac57ea226f682e507c79ad1338d9dd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_320_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>320</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a52dd8cd81d96b308b5088db059275762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_352_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>352</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a6fd7146bb2466447d04f74ce5f7def80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_384_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>384</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a5c746ad021307f50c2005d6043ab5a05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_416_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>416</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="ab416912e186693889f954d3491d6cb0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_448_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>448</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a95557bee413c7de118239b94ca73585b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_480_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>480</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a6f33f9f028e13832f14873b6deb7a32c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_512_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>512</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
<a class="anchor" id="a98557ab36e5ee51547221d9938db98cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MTToolBox::prime_factors2_544_1[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2<sup>544</sup>-1 の素因数分解に現れる素数のリスト </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
2016年10月12日(水) 13時45分38秒作成 - MTToolBox / 構成:  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
